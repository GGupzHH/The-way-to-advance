# model-2 ES新特性与TypeScript、JS性能优化


## 一 请输出下列最终执行结果，并解释为什么
  - 代码
    ```js
      var a = []
      for (var i = 0; i < 10; i++) {
        a[i] = function () {
          console.log(i)
        }
      }

      a[6]()
    ```
  - 解释
    ```txt
      a[6]() // 10
      因为for循环定义的循环变量使用var定义，var在for循环里面定义的变量是挂载到全局的
      当循环结束之后这个变量并没有被销毁，在调用a[6]()这个函数的时候，而这里的i是已经完成循环的 所以是10
      
      如果想输出6
      方法一: let let作用域是块级的  for也会产生一个块级作用域 在函数声明的时候函数内部存在一个对当前i的引用
      方法二: 闭包 将函数声明的地方使用闭包，这样就将当前i的值作为一个参数传入
      方法三: 使用setTimeout包裹函数声明  setTimeout有第三个参数，第三个参数会直接作为参数传入 但是这里使用settimeout会变成异步执行 并不能立即得到结果 想要得到正确的结果需要使用Promise解决异步
    ```

## 二 请输出下列最终执行结果，并解释为什么
  - 代码
    ```js
      var tmp = 123

      if(true) {
        console.log(tmp)
        let tmp
      }
    ```
  - 解释
    ```txt
    // Error 报错
    原因: var声明的变量是全局的，if判断默认执行 形成一个块级作用域 console.log(tmp) 因为当前if形成的作用域内存在tmp变量 但是变量还没有声明，let定义的变量不能在当前作用域内声明之前使用(暂时性死区)
    ```
    
## 三 结合ES6新语法，用最简单的方式找出数组中的最小值
  - 代码
    ```js
      var arr = [12, 34, 32, 89, 4]
    ```
  - 实现
    ```js
      let [ firstItem ] = arr.sort((a, b) => a - b)
    ```
    
## 四 请详细描述var, let, const三种声明变量的方式之间的具体差别
  ```txt
    var: 从js诞生就存在的声明变量的关键词，var声明的变量是在当前域的变量(如果是函数内部声明则是局部变量) var声明会存在变量提升，也就是可以在声明之前使用，但是值为undefined

    let、const: ECMAScript2015提出的新的声明变量的关键词，相对于var，let、const不存在变量提升，如果在声明之前使用会造成暂时性死区(程序执行错误，停止执行)，而且let、const有了新的作用域使用定义，也就是块级作用域(每一个{}都会形成一个块级作用域)，而且只在当前块级作用域生效，let声明的变量可以任意改变，const声明常量，声明之后不能改变(声明对象类型，因为只是保存了对象的内存地址，所以不管对象内部怎么变化都可以)
  ```

## 五 请输出下列最终执行结果，并解释为什么
  - 代码
    ```js
      var a = 10
      var obj = {
        a: 20,
        fn() {
          setTimeout(() => {
            console.log(this.a)
          })
        }
      }
      obj.fn()
    ```
  - 解释
    ```txt
      obj.fn() // 20
      因为是obj调用的fn函数  那么函数内部的this指向的是当前的对象obj
      也就是说fn函数内部的this指向的是obj对象，然后setTimeout回调函数是一个箭头函数
      箭头函数不存在this 当箭头函数内部使用this的时候 此时会去当前箭头函数声明的作用域找this 而声明这个箭头函数的作用域就是fn函数内部的作用域 所以this.a  就相当于在fn函数内部this.a  也就是obj.a
    ```

## 六 简述Symbol类型的用途
  ```txt
    因为每一个Symbol都是独一无二的，不可能存在相同的Symbol。
    当我们使用Symbol定义对象的键的时候，该键值无法从外部获取，让"对内操作"和"对外输出"更为优雅。
  ```

## 七 说说什么是浅拷贝、深拷贝
  - 浅拷贝
    ```txt
      将复杂数据类型的存储地址赋值给另一个变量，此时两个变量引用的是同一存储空间的数据，当改变一个变量内部的值之后(不重新复制等操作) 就相当于把根数据改了
    ```
    ```js
      let a = {
        name: {
          Last: 'z',
          names: 'hh'
        }
      }
      let b = a;
      let c = Object.assign(a)
    ```
  - 深拷贝
    ```txt
      将目标变量一层层递归遍历 直到找到不存在引用关系的时候，可以理解为自食其力，自身的所有属性都是本身创建的  并不存在引用其他数据的
    ```

## 八 简述TS JS之间的关系
  ```txt
    TS是JS的一个超集，TS结合了js本身的一部分语法，但又弥补了js是一门弱类型语言的不足。
  ```

## 九 谈谈你所认识TS的优缺点
  - 优点
    ```txt
      强类型语言，可以在开发阶段就避免很多数据类型错误，并且编译直接是js，而且是渐进式的一门语言。
    ```
  - 缺点
    ```txt
      小型项目不适合使用，增加开发成本。
    ```

## 十 描述引用计数的原理和优缺点
  - 原理
    ```txt
      每个存储空间设置一个引用数，当改变引用关系的时候改变引用数，当引用数为0的时候，回收释放
    ```
  - 优点
    ```txt
      发现垃圾立即回收，最大程度的减少程序的暂停
    ```
  - 缺点
    ```txt
      资源消耗大(时间更久)
      无法回收循环引用的对象，因为这两个对象上的计数器永远不为0
    ```

## 十一 描述标记整理算法的工作流程
  ```txt
    标记整理是标记清除的增强版
    遍历所有对象标记活动对象，之后遍历所有对象清除没有标记的对象回收
    最后将碎片化的存储空间重新整理排序
  ```

## 十二 描述V8中新生代存储区垃圾回收的流程
  ```txt
    首先新生代存储区一分为二，分为from(使用空间)和to(空闲空间)
    当前有使用内存空间的就分配到from空间
    当form空间达到一定程度的时候们就会标记整理后拷贝到To空间
    拷贝之后To空间有了备份就会清除from空间
    拷贝过程中可能会存在晋升(新生代对象移动到老生代中)
    晋升
      当前老生代对象中已经有了或者是当前对象经过一轮GC处理还活着，又或者是To区域占用率达到25%的时候，当前新生代对象都移动到老生代对象中
  ```

## 十三 描述增量标记算法在何时使用及工作原理
  ```txt
    增量标记算法在新生代晋升的时候，此时老生代的存储的空间不足的时候回执行增量标记算法
    增量标记算法是在程序执行的时候就去执行，也就是说会阻塞程序执行，但是这个时间超级超级短。
    在程序执行的时，先去遍历对象进行标记，然后让程序执行一会，之后接着标记一部分(增量标记)，之后完成清除，程序接着运行。
  ```
